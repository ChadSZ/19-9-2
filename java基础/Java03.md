## 多线程Thread
### 软件开发：高可用，高性能，高并发

1. 程序，进程Process，线程Thread
   1. 操作系统中运行的即是程序
   2. 每一个程序即是一个进程，作为资源分配的单位
   3. 线程是进程中开辟多条路径，调度和执行的单位
   4. 多线程。即是指有多个CUP，即多核。如服务器

2. 线程就是独立的执行路径
3. 在程序运行是，即使没有自己创建线程，后台也会存在多个线程，如gc线程，主线程
4. main() 称之为主线程，为系统的入口点，用于执行整个程序
5. 多线程，运行是由调度器安排调度，调度器是与操作系统紧密相关的，不能人为干预
6. 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制
7. 线程会带来额外开销，如CPU调度时间，并发控制开销
8. 每个线程在自己的工作内存交互，加载和存储主内存控制不当会造成数据不一致


## 创建线程一
1. 继承Thread类，有**start方法，开启新线程，不一定立即执行，由CPU来执行线程**
2. 实现Runnable接口，没有start方法，没有和CPU交互能力
3. 实现Callable接口
4. 重写run方法，这是线程的入口点


## 创建线程二
1. 创建：实现Runnable+重写run
2. 启动：创建实现类对象+Thread代理对象+start

3. 推荐：避免**单继承的局限性**(java仅能继承一个父类Thread)，优先使用接口
4. 方便共享资源


## 实现Callable
1. 创建目标对象
2. 创建执行服务 ExecutorService ser = Executors.newFixedThreadPool(3);
3. 提交执行	Future``<Integer>`` result1 = ser.submit(cracer);
4. 获取结果 Integer r1 = result1.get();
5. 关闭服务 ser.shutdownNow();



## 简化线程 Lambda
1. 外部类
2. 静态内部类
   1. 使用，才会进行编译，不使用，不编译
3. 匿名内部类
4. 实现Runnable的简化
   1. lambda：不传参数
   2. lambda：传参数
   3. lambda：单行代码，继续简化
   4. lambda：带返回值
   5. 函数式编程：lambda01 = (a,b)->a+b;


## 线程状态
1. 新生状态：创建线程对象

2. 就绪状态：调用start方法进入就绪队列，具备运行能力
   1. start
   2. 阻塞解除
   3. yield，让当前正在执行线程暂停，转入就绪状态；如果没有其他等带执行的线程，当前线程会马上恢复执行
   4. jvm，通过CPU将本地线程切换到其他线程

3. 运行状态：CPU调度，进入运行状态，执行线程体的代码块

4. 阻塞状态：调用sleep,wait或synchronize(同步)锁定时，会进入阻塞状态
   1. sleep：延时，抢夺资源(lock的概念)，没有其他等带执行的线程，使当前线程停止运行一段时间，将处于阻塞状态
   2. wait：不抢夺资源，其他线程可用
   3. join：合并线程，待此线程执行完后，在执行其他线程，其他线程阻塞
   4. read write 都会进入阻塞

5. 死亡状态
   1. stop ： **不推荐使用**
   2. destroy
   3. 通常终止线程方式有两种：
      1. 让代码执行完成
      2. 外部干涉，让代码执行完成

6. 守护线程
   1. setDaemon，将指定的线程设置成后台线程，守护线程
   2. 创建用户线程结束时，后台线程也随之消亡
   3. 只能在线程启动之前把它设为后台线程

7. setPriority getPriority
   1. 线程的优先级代表的是概率
   2. 范围是从1-10，默认为5


## 阻塞状态
### sleep
1. sleep指定阻塞线程的毫秒数
2. sleep不会释放锁
3. 存在异常，InterruptedException。run方法不能对外**throws声明异常**。所以，需要**try--catch捕获异常**
4. 时间到达后，进入就绪状态
5. 模拟网络延时，倒计时等
6. 某个线程调用了slee方法，该线程类对象触发sleep时，就会进入阻塞(main,gc,...任何线程都可能会)

### join 
1. 阻塞的目标是调用该方法的线程类对象。 


## Priority
1. 优先级低只是意味着获得调度的概率低。并不是绝对调度优先级高的


## 守护线程
1. 线程分为用户线程和守护线程
2. JVM必须确保用户线程执行完毕
3. JVM不必等待守护线程执行完毕
4. 如后台记录操作日志、监控内存使用等


# UGC 理念


## 常用其他方法
1. isAlive()：判断线程是否还活着
2. Thread.currentThread()：当前线程
3. setName、getName：代理名称


## 线程不安全
1. 在修改数据时，需要保证数据安全；单独读取数据，并不一定要保证线程安全
2. 并发三要素：
   1. 操作同一个对象
   2. 多个线程操作
   3. 同时操作

## 线程同步
1. 同一个进程多线程，带来方便，但是会带来访问冲突，造成并发不安全情况。所以我们可以加上锁机制(synchronized)，当一个线程获得对象的排它锁，独占资源，其他线程需要等待，使用后释放锁即可。
2. 线程持有锁会导致其他所有需要此锁的线程挂起
3. 在多线程竞争的情况下，加锁、释放锁，会导致比较多的上下文切换和调度延时，引起性能问题
4. 如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题

5. 我们通过private 保证数据对象仅能被方法访问，所以我们仅需对方法提出机制，synchronized
   1. synchronized 方法
   2. synchronized 块
   3. 该关键之**控制对 "成员变量|类变量" 对象的访问**(对象的成员变量或类变量被锁住)：每个对象对应一把锁，每个synchronized 方法都必须获得调用该方法的对象的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，知道从该方法返回时才将锁释放，此后被阻塞的线程放能获得该锁，重新进入可执行状态。
6. 缺陷：若将一个大的方法声明为synchronized将会大大影响效率

7. 关于块
   1. 方法内部定义块，即局部快。用于解决变量作用域，快速释放内存
   2. 类中定义块，即构造块。同构造器，用于初始化对象
   3. 类中定义static块，即静态块。用于初始化加载类
   4. 同步块，方法中定义。
      1. synchronized(obj){  }，obj称之为同步监视器
      2. obj可以是任何对象，但是推荐使用共享资源作为同步监视器
      3. 同步方法中无需指定同步监视器，因为同步方法的同步监视器是this，即对象本身，或class(类的模子)
8. 同步监视器的执行过程
   1. 第一个线程访问，锁定同步监视器，执行其中的代码
   2. 第二个线程访问，发现同步监视器被锁定，无法访问
   3. 第一个线程访问完毕，解锁同步监视器
   4. 第二个线程访问，发现同步监视器未锁，锁定并访问

* 注意：锁定锁的是对象，保证堆内存中的地址不变；而本身值的变化，并没有锁定本质

9. **double checking** 双重检测，提高性能。多用同步块

10. 扩展：操作容器时，使用**并发容器**
    1.  CopyOnWriteArrayList


## 死锁现象
1. 多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能进行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。某一个同步块同时拥有"两个以上对象的锁"时，发生死锁的可能。
2. 解决方法：不使用同步套同步


## 线程协作
1. taobao：
   1. PV: Page view
   2. UV: Unique view
   3. VV: Visit view
2. Alibaba:
   1. p7-p12
3. 肯德基和麦当劳
   1. 麦当劳：先收钱(生产者消费者模式)，一对一模式
   2. 肯德基：先给食物，之后再收钱(BIO模式)，一对多模式
4. synchronized 可阻止并发更新同一个共享资源，实现同步
5. 但是，synchronized不能用来实现不同线程之间的消息传递(通信)
6. 解决线程通信的两种方法：
   1. 管程法："缓冲区"，解耦
   2. 信号灯法


## 高级--定时调度
1. 通过Timer 和TimerTask，我们可以实现定时启动某个线程
   1. java.util.Timer：类似闹钟，本身实现的就是一个线程
      1. 该类。可以安排一次执行，或者定期重复执行  
   2. java.util.TimerTask：一个抽象类，实现了Runnable接口，所以剧本多线程的能力 
2. QUARTZ(石英表)
   1. Scheduler - 调度器，控制所有的调度
   2. Trigger - 触发条件，采用DSL模式
   3. JobDetail - 需要处理的JOB
   4. Job - 执行逻辑
   5. DSL：Domain-specific language 领域特定语言，针对一个特定的领域，具有受限表达式的一种计算机程序语言，即领域专用语言，声明式编程：
      1. Method Chaining 方法链 Fluent Style 流畅风格， builder模式构建器
      2. Nested Functions 嵌套函数
      3. Lambda Expressions/Closures
      4. Functional Sequence


## volatile 
1. volatile 保证线程间变量的可见性
   1. 线程对变量进行修改之后，要立刻回写到主内存
   2. 线程对变量读取的时候，要从主内存中读，而不是缓存
   3. 保证数据的可见，即轻量级的synchronized
   4. 不保证原子性 


## 单例模式
1. double-checking 
2. volatile


## ThreadLocal
* 每个线程都有自己的数据。一个线程使用自己的局部变量要比使用全局变量摇号，因为局部变量只有线程自己看得见，不会影响其他线程
1. set
2. get
3. initialValue


## 可重入锁
1. 锁作为并发共享数据保证一致性的工具，大多数内置锁都是可重入的，如果某个线程视图获取一个已经由它自己持有的锁时，那么这个请求会立刻成功，并且会将这个锁的计数值加1，而当线程退出同步代码块时，计数器将会递减，当计数值等于0时，锁释放。如果没有可重入锁的支持，在第二次企图获得锁时会进入死锁状态。


## CAS
1. 悲观锁
   1. synchronized，独占锁即悲观锁。会导致其他所有需要锁的线程挂起，等待持有锁的线程释放锁。
2. 乐观锁
   1. 每次不加锁而是假设没有冲突二区完成某项操作，如果因为冲突失败就重试，直到成功为止。
3. Compare and Swap 比较并交换
   1. 乐观锁
   2. 有三个值，V(当前内存值)，A(旧的预期值)，B(将要更新的值)
   3. CAS是一组原子操作，不会被外部打断
   4. 属于硬件级别的操作(CPU的CAS指令，同时借助JNI完成非阻塞算法)，效率比加锁操作高
   5. ABA问题：变量V在初次读取的时候是A，在准备赋值的时候检查仍是A，在这段时间内，曾经被改为B，然后又改为A，那么CAS就会误认为它从来没有被修改过。
   6. 注意：**native 修饰符**，代表是硬件来实现的，效率非常高。